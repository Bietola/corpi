"<m+tab><m-2><m-1>kko<esc>ko<wbf>solve :: [Int<esc>A<wbf> -> [Int<esc>ds]o<wbf>solve : <esc>ddkyypf:C<wbf>in<esc>bC<wbf>lst = <esc>bbcwi<wbf>np<esc>A<wbf>zip inp inp<esc>BBBi<wbf>map <esc>uA<wbf><cr><tab>& mul<esc>bC<wbf>map mul<esc>bC<wbf>*<esc>i<wbf>(<esc>lxA<wbf>)<esc>bc<cps>lcl+<cps>BBC<wbf>filter \\<esc>cc<cps>uA<wbf><esc>bf\\C<wbf>()<esc>hi<wbf>\\<esc>la<wbf>x, y<esc>A<wbf>-<bs> -> x + y == 2020<cr>& take 1<cr><esc>ddkftC<wbf>head<esc>A<wbf><esc>kf\\i<wbf>(l<bs><esc>lxA<wbf>)<esc>jo<wbf>& (\\(x, y<esc>la<wbf>-<bs> -> x * <bs><bs>* y<esc>:w<cr>BBBBBBllC<wbf>(*<esc>:w<cr>jjjA<wbf>solve<esc>bi<wbf>getCon<tab> >>= <esc>bbKkkkkkkkV}}ddddd:w<cr>ka<wbf>za<tab><cr><cr><m-2><m-1>imain :: IO ()<cr>main = solve<esc>ggO<wbf><esc>O<wbf>solve = <esc>O<wbf>solve :: [Int<esc>A<wbf> -> Int<esc>jA<wbf>zip<esc>Bbi<wbf>inp <esc>A<wbf> inp inp<cr><tab>& i<bs>filter (\\(x, y) -> x + y == 2020<esc>o<wbf>& head<cr><esc>ddkA<wbf> & (*<esc>jjkkkbbbbjbbbbbbbkkO<wbf><esc>O<wbf>impo<tab> Pre<tab><esc>bC<wbf>Da<tab><esc>bC<wbf>Fuc<tab><tab><tab><tab><tab><tab><esc>:w<cr>}}kf&;xi<wbf><><esc>i<wbf>*<esc><m-2>O<wbf>haskell fold over tubp<bs><bs><bs>uple<cr>j<cr><m-1><sm+cr><m- >ghci<cr>foldl (+)<bs>2) (q, <bs><bs><bs>1 ,<bs><bs>, 2, 3)<cr><esc>kA<wbf><esc>BBBi<wbf>1 <cr><esc>k<cps>f+xxi<wbf>+<cr><esc>kf1<cps>f(C<wbf>[1, 2, 3]<cr><esc>kf[C<wbf>()<esc>i<wbf><m-2><esc>o<wbf>haskell fold over tuple<cr>jjjjk<cr> gg<m-1><esc><cps><sm-C<wbf>>bC<esc>xyp<cps>yypfhC<wbf>(\\(x, y<esc>A<wbf><esc>i<wbf> -> x * y<esc>:w<cr>kjds)<cps>ds)<cps>BBBBBC<wbf>uncu<tab> <bs><bs>y<tab> (*<esc>:w<cr>kJ:w<cr>}}A<wbf> <bs><esc>bi<wbf>getCon<tab> >>= <esc>BBKEEa<wbf> wor<tab><esc>bcwli<wbf>nes<tab><esc>a<wbf> .<esc>bdwA<wbf><esc>bdwxa<wbf><esc>i<wbf>solve <esc>A<wbf> lines<esc>bbbea<wbf> read<esc>bi<wbf>. <esc>ebbbbdwbdwA<wbf> <<<esc>hi<wbf>=<esc>A<wbf> e<bs>get<tab><tab><tab><esc>:w<cr>BBBBbbbi<wbf>printF<bs><esc>ui<wbf>putS<tab><tab> $ <esc>lbdwi<wbf>=<bs><esc>f=dWi<wbf><> <esc>i<wbf><esc>i<wbf>&<esc>BBBBBf<BBBBBi<wbf> <esc>i<wbf><><esc>ha<wbf>$<esc>eebi<wbf>getCon<tab> <$> <esc>f>bDx:w<cr>kjf<;<cps>f<cps>F<;xxxi<wbf>=<<<esc>:w<cr>bdwi<wbf>. <esc>eehhxxxi<wbf>=<<<esc>:w<cr>bbEEEflKbbi<wbf>fa<bs>map <esc>bflKbbKbKbbKffxBbKbxxxbbbdwdwelxxi<wbf> ==<bs><bs>=<bs>>>= <esc>bdWi<wbf><$> <esc>blA<wbf> >>= print<esc>bC<wbf>putS<tab><tab><esc>BBBBBBBBBBi<wbf><cr>contents <- <esc>bbcwi<wbf>npt<esc>kjkjxkA<wbf><esc>jbf<cps>kA<wbf> <bs> do<esc>jea<wbf><cr><esc>ldWi<wbf><esc>eeEEEEa<wbf>i<bs> inp<esc>bbea<wbf>)<esc>BBBBBbi<wbf>(<esc>I<wbf>putStrLn $ <esc>f>Dx:w<cr>BBBBBBBBebbcwpri<wbf>nt<esc>bea<wbf>Ln<esc>hxx:w<cr>kjkA<wbf> <<esc>uV<cps>kkV}gc}kkkV}t<cps><cps>kkkVgd}y}pko<wbf><esc>jkxxjgcgcu}}kkkV}gc}kddddbC<wbf>e<bs>getCon<tab> <$><esc>BBi<wbf>=<<<esc>hhi<wbf>print <esc>llea<wbf> <esc>A<wbf><esc>bbi<wbf>(<esc>A<wbf> solve . map read . lines<esc>A<wbf>)<esc>:w<cr>BBBBBBBBBdWbdwA<wbf>=<bs> ==<bs><bs>>>= print<esc>:w<cr>bbbbbbbbbbbdwxxxxf)i<wbf> <$> geton<bs><tab>c<bs><bs>C<tab><esc>:w<cr>kjBBBBBBBBlds)f<dWBBBBBBfgdwBBBBBBPa<wbf>>>= <esc>a<wbf>print . <esc>f=bDx:w<cr>Fgi<wbf><cr><esc>kA<wbf><bs><esc>:w<cr>3kda<wbf>p:w<cr>/zip<cr>dwicarte<esc>u<m-2><cps>o<wbf>haskell all combinations<cr>j<cr><c-d><c-d><m-1>ea <*><esc>bbi<wbf>()<esc>i<wbf>,<esc>xi<wbf>*<esc>la<wbf><esc>hui<wbf>,) <$> <esc>:w<cr>BBi<wbf>Li<bs><bs>liftA2 <esc>eebdwf<dwdwx:w<cr>A<wbf><esc>BBB<m-2><m-1>ggyypfDcwC<wbf>on<tab><esc>bdwi<wbf>Appl<tab><esc>lD:w<cr>jjjj<m-2><m-1><m-2><m-1>kBBBKA<wbf> inp<esc>:w<cr>ha<wbf>skell-aoc2<bs>-1p1<cr><m-7><m-1><c-c>"
